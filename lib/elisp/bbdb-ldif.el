From VM Mon Jul 13 14:58:21 1998
Content-Length: 13693
X-VM-v5-Data: ([nil nil nil nil nil nil nil nil nil]
	[nil "Mon" "13" "July" "1998" "14:11:24" "+0200" "Niels Elgaard Larsen" "elgaard@diku.dk" nil "402" "bbdb-ldif.el, BBDB and Netscape Address Book" "^From:" "info-bbdb@xemacs.org" "BBDB mailinglist" "7" nil nil nil nil nil]
	nil)
Received: from piinbh1.ms.com (piinbh1-i0.morgan.com [199.89.110.33])
        by samail1.ms.com (8.8.5/hub v1.86) with ESMTP id IAA28988;
        Mon, 13 Jul 1998 08:48:38 -0400 (EDT)
Received: (from uucp@localhost)
        by piinbh1.ms.com (8.8.6/fw v1.22) id IAA02721;
        Mon, 13 Jul 1998 08:45:15 -0400 (EDT)
Received: from gwyn.tux.org(207.96.122.8) by piinbh1.ms.com via smap (4.0a)
	id xma002375; Mon, 13 Jul 98 08:44:55 -0400
Received: (from majordom@localhost)
	by gwyn.tux.org (8.8.8/8.8.8) id IAA19506
	for bbdb-info-out; Mon, 13 Jul 1998 08:11:30 -0400
Received: from vidar.diku.dk (root@vidar.diku.dk [130.225.96.249])
	by gwyn.tux.org (8.8.8/8.8.8) with ESMTP id IAA19502
	for <info-bbdb@xemacs.org>; Mon, 13 Jul 1998 08:11:27 -0400
Received: from grimer.diku.dk (grimer.diku.dk [130.225.96.251])
	by vidar.diku.dk (8.9.0/8.9.0) with ESMTP id OAA20721
	for <info-bbdb@xemacs.org>; Mon, 13 Jul 1998 14:11:25 +0200 (METDST)
Received: (elgaard@localhost) by grimer.diku.dk (8.9.0/8.6.12) id OAA13870; Mon, 13 Jul 1998 14:11:24 +0200 (METDST)
Message-Id: <199807131211.OAA13870@grimer.diku.dk>
Reply-To: elgaard@diku.dk (Niels Elgaard Larsen)
Organization: DIKU, Dept. of Computer Science, University of Copenhagen
Address: Universitetsparken 1, DK-2100  Copenhagen, Denmark
Phone: +45 35321381, fax: +45 35321401, University: +45 35321818
X-Face:  ,Bd|^Ac`}H@z_2w?,mpej+PrLVA6Xw$FcK^-IxdvEO(vacEs_d~R|{Pk(Gs&pR
 j"&w&:C\)%Zw9jh:NxA,fFH*3BZ]?)"PkK,!218f193dn2XhBhB*%/nH);_E)6wq29u
 `=+j)RV4]oNETx^Z>VNhZn{i~DS+0yW!6R$=tf0`7&Fqi.||?aY5=e.Svp6oKGigWZ80pj
 l^:>:-02x>a!P#jg_I^o2]9Y2<^u
Precedence: bulk
X-Mailing-List: <bbdb-info@xemacs.org>
From: Niels Elgaard Larsen <elgaard@diku.dk>
Sender: owner-bbdb-info@xemacs.org
To: BBDB mailinglist <info-bbdb@xemacs.org>
Subject: bbdb-ldif.el, BBDB and Netscape Address Book
Date: Mon, 13 Jul 1998 14:11:24 +0200 (METDST)
Mime-Version: 1.0 (generated by tm-edit 7.108)
Content-Type: multipart/mixed;
 boundary="Multipart_Mon_Jul_13_14:11:23_1998-1"
Content-Transfer-Encoding: 7bit

--Multipart_Mon_Jul_13_14:11:23_1998-1
Content-Type: text/plain; charset=US-ASCII

I have written bbdb.el. It can read LDIF records produced by Netscape
Communicator address book (bbdb-import-ldif) and write LDIF records, that can
be imported in Netscape address book.

;;;========= start bbdb.ldif.el=============

;     This program is free software; you can redistribute it and/or modify
;     it under the terms of the GNU General Public License as published by
;     the Free Software Foundation; either version 2 of the License, or
;     (at your option) any later version.

;     This program is distributed in the hope that it will be useful,
;     but WITHOUT ANY WARRANTY; without even the implied warranty of
;     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;     GNU General Public License for more details.

;     You should have received a copy of the GNU General Public License
;     along with this program; if not, write to the Free Software
;     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

; Niels Elgaard Larsen, <URL:mailto:elgaard@diku.dk>
; July 7, 1998

; bbdb-import-ldif imports LDIF entries
; bbdb-to-ldif export bbdb to LDIF.

; Both functions are somewhat specialized for Netscape Communicator.

; UNCOMMENT NEXT LINE if MEL installed
;(require 'mel)

(require 'bbdb)
;(require 'bbdb-snarf)
(require 'bbdb-com)

(defun addnote (nrec nname note)
  (bbdb-record-set-raw-notes 
   nrec (cons (cons nname note)  (bbdb-record-raw-notes nrec)  ) 
   )
  )

(defmacro dodenote (st)
  (if (fboundp 'base64-decode-string)
      (base64-decode-string (eval st))
    "?"
    )
)


(defun setphone (nrec ploc pno)
  (let ((nov (bbdb-parse-phone-number pno))
	(pv (make-vector bbdb-phone-length ""))
	)

  (if (and nov bbdb-north-american-phone-numbers-p)
      (progn
	(bbdb-phone-set-location pv ploc)
	(bbdb-phone-set-area pv (nth 0 nov)) 
	(bbdb-phone-set-exchange pv (nth 1 nov))
	(bbdb-phone-set-suffix pv (nth 2 nov))
	(bbdb-phone-set-extension pv (or (nth 3 nov) 0))
	)
    (setq pv (vector ploc pno))
    )
  (bbdb-record-set-phones 
   new-record (cons  pv ( bbdb-record-phones new-record)))
  )
  )

(defun bbdb-import-ldif () 
  (interactive)
  "import LDIF entries for current buffer"
  (goto-char (point-min))
  (while (looking-at "\n") (forward-line 1))
  (while (< (point) (point-max))
    (message (concat  (/(* 100 (point)) (point-max)) " pct\n"))     
;;    (message (concat "\nnew rec  at" (point)))
    (let (
	  attName coco attVal netAddr
		  (new-record   (make-vector bbdb-record-length nil))		 
		 (taddr   (make-vector bbdb-address-length ""))
      )
      (bbdb-record-set-cache new-record (make-vector bbdb-cache-length nil))
      (while (and (< (point) (point-max))(not (looking-at "\n")))
;;;      (re-search-forward "^\\(\\S-+\\):\\(:*\\)\\s-*\\(\\.*\\)$" nil nil nil)
	(if  (re-search-forward "^\\([a-zA-Z]+\\):\\(:?\\) *\\(.*\\)$" (point-max) t)
	    
	    (progn
	      (setq attName (match-string 1))
	      (setq coco (not (equal (match-string 2) "")))
	      (setq attVal (match-string 3))
;;	      (message (concat attName " is " attVal))
	      (cond 
		       ((or (equal attName "sn") (equal attName "surname")) (bbdb-record-set-lastname new-record attVal))
		       ((equal attName "givenname") (bbdb-record-set-firstname new-record attVal))
		       ((equal attName "o") (bbdb-record-set-company new-record attVal))
		       ((equal attName "locality") (bbdb-address-set-city taddr attVal))
		       ((equal attName "postalcode") (bbdb-address-set-zip taddr attVal))
		       ((equal attName "st") (bbdb-address-set-state taddr attVal))
		       ((equal attName "postalcode") (bbdb-address-set-zip taddr attVal))


		       ;; This is ugly. But is it the only way Netscape understands.
		       ((equal attName "postOfficeBox") (bbdb-address-set-street1 taddr attVal))
		       ((equal attName "streetaddress") (bbdb-address-set-street2 taddr attVal))
		       
		       ((equal attName "mail") (bbdb-record-set-net new-record (list attVal))
			(setq netAddr attVal)
			)

		       ((equal attName "homephone")  (setphone new-record "Private" attVal))

		       ((equal attName "facsimiletelephonenumber")   (setphone new-record "Fax" attVal))

		       ((equal attName "telephonenumber")   (setphone new-record "Work" attVal))

		       ((equal attName "xmozillanickname") 
			(bbdb-record-set-aka  new-record (list attVal)))
		       ((equal attName "description") 
			(if coco
			    (let ((sst attVal))
			      (while (re-search-forward "\n +\\([0-9a-zA-Z\\+]+\\)=*\\s-*$" nil t)
				(setq sst (concat sst (match-string 1))))
			      (addnote new-record 'notes (dodenote sst))
			      )
			  (addnote new-record 'notes attVal)
			  )
			)
		       ((equal attName "createTimestamp") (addnote new-record 'creation-date attVal))
		       ((equal attName "modifyTimestamp") (addnote new-record 'timestamp attVal))
		       )
		)
	  )
	(forward-line 1)
	)
      (if (or (bbdb-address-zip new-record) (bbdb-address-street1 new-record)
	      (bbdb-address-city new-record) (bbdb-address-state new-record))
	  (progn 
	    (bbdb-address-set-location taddr "address")
	    (bbdb-record-set-addresses new-record (list taddr))
	  )
	)
      (let      ((old-record (bbdb-search-simple (bbdb-record-name new-record) netAddr)))
	(if old-record
	    (progn
	      (setq new-record (bbdb-merge-internally-ldif old-record new-record))
	      (bbdb-delete-record-internal old-record)))
    ;; create  new record
	(bbdb-invoke-hook 'bbdb-create-hook new-record)
	(bbdb-change-record new-record t)
	(bbdb-hash-record new-record)
      )
      )
    (while (looking-at "\n") (forward-line 1))
    )
)



(defun tr (str fr to)
  (let ((inx 0)
	(lnx (length str))
	(tstr (substring str 0))
	)
    (while (< inx lnx)
      (if (eq (aref str inx) fr) (aset tstr inx to))
      (setq inx (1+ inx))
      )
    tstr
    )
  )

(defun bbase64-encode-string (st)
      (concat ":" (tr
       (base64-encode-string st)
       ?\n ? ))
)

(defmacro donote (st)
  (if (fboundp 'base64-encode-string)
      (bbase64-encode-string (eval st))
    (tr (eval st) ?\n ?$)
    )
)

(defun nsloc (pl) "Guess mapping from userdefined bbdb locations to NS Work/Home/Fax"
  (let ((pld (downcase pl))
	(fc (string-to-char (downcase pl)))
	)
    (cond  ((or (= fc ?a) (= fc ?w))  "telephonenumber")	 
	   ( (= fc ?h)	"homephone")	 
	   ( (= fc ?m)	"mobileTelephoneNumber")	 
	   ( (equal pld "fax")	"facsimiletelephonenumber")	 
	   ( t	"telephonenumber")
	   )
    )
)

(defun tnil(tt) 
  (if tt "t" "nil"))
(defvar ldifbuffer "*LDIF*" "Name of buffer for LDIF output")
(defun bbdb-to-ldif (visible-records) "Converts BBDB to LDIF format. Can be used to export bbdb to Netscape 
Communicator Address book.\\<bbdb-mode-map>
If \"\\[bbdb-apply-next-command-to-all-records]\\[bbdb2ldif]\" is \
used instead of simply \"\\[bbdb2ldif]\", then includes only the 
people currently in the *BBDB* buffer.
The result is placed in a buffer name \"*LDIF*\"
If  MEL is installed Multiline notes/descriptions work with Netscape address book.
"
  (interactive (list 
		(bbdb-do-all-records-p)
		)
	       )
  (let* (
	 (target (cons bbdb-define-all-aliases-field "."))
	 (records 
	  (bbdb-search 
	   (if (not visible-records)
	       (bbdb-records)
	     (mapcar 'car bbdb-records)
	     )
	   nil nil nil target)
	  )
	 tmps	 
	 record 
	 (lists nil)
	 (single-aliases nil)
	 (count 0)
	 )
    (setq result nil)


    (setq records 
	  (if (not visible-records)
	      (bbdb-records)
	    (mapcar 'car bbdb-records)
	    )
	  )

    (set-buffer (get-buffer-create ldifbuffer))
    (setq fill-column 1000)
    (erase-buffer)

    (while records
      (setq record (car records))
      (insert "\nxmozillausehtmlmail: FALSE\n")
      (let (
	    (net (car (bbdb-record-net record)))
	    (rnet  (bbdb-record-net record))
	    )
	(if net (insert "mail:" net "\n"))
	(while (cdr rnet)
	  (insert "mailAlternateAddress:" (cadr rnet) "\n")
	  (setq rnet (cdr rnet))
	  )
	(setq tmps (bbdb-record-firstname record)) (if tmps  (insert "givenname:"   tmps "\n"))
	(setq tmps (bbdb-record-lastname record))	(if tmps (insert "sn:"  tmps "\n"))
	(insert "objectclass: top\nobjectclass: person\n")
	(setq tmps (bbdb-record-company record)) 	(if tmps (insert "o:" tmps "\n"))
	(setq tmps (bbdb-record-name record))	(if tmps (insert "cn:"  tmps "\n"))
	)

      (let (
	    (phones (bbdb-record-phones record))
	    (addrs (bbdb-record-addresses record))
	    (aka (bbdb-record-aka record))
	    (tonote nil)
	    (firstaddr t)
	    phone
	    )

	(while phones
	  (setq phone (car phones))
	  (if (equal (nsloc (bbdb-phone-location phone))"mobileTelephoneNumber")
	      (setq tonote (concat tonote "M:" (bbdb-phone-string phone) "\n"))
	    (insert (format "%s: " (nsloc (bbdb-phone-location phone))) (bbdb-phone-string phone) "\n")
	    )
	  (setq phones (cdr phones)))

	(let (addr c tmps)
	  (while  addrs
	    (setq addr (car addrs))
	    (if firstaddr (progn			   
		(if (= 0 (length (setq tmps (bbdb-address-street1 addr)))) nil  (insert "postOfficeBox:" tmps "\n"))
		(if (= 0 (length (setq tmps (bbdb-address-street2 addr)))) nil  (insert "streetaddress:" tmps "\n"))
		(if (= 0 (length (setq tmps (bbdb-address-street3 addr)))) nil  (insert "streetaddress:" tmps "\n" ))
	      
	   ; This does not work with Netscape				
	   ; (if (= 0 (length (setq tmps (bbdb-address-street1 addr)))) nil  (insert "homePostalAddress:" tmps ))
	   ; (if (= 0 (length (setq tmps (bbdb-address-street2 addr)))) nil  (insert "$" tmps))
	   ; (if (= 0 (length (setq tmps (bbdb-address-street3 addr)))) nil  (insert "$" tmps ))
	   ; (insert "\n")

		(insert "locality:" (setq c (bbdb-address-city addr)) "\n")
		(setq tmps (bbdb-address-state addr))
		(if (and tmps (not (equal tmps ""))) (insert "st:" tmps "\n"))
		(if (bbdb-address-zip-string addr)
		    (insert "postalcode:" (bbdb-address-zip-string addr) "\n"))
		(setq firstaddr nil)
		)
	      (progn
		(setq tonote (concat tonote (bbdb-address-street1 addr) "\n" (bbdb-address-street2 addr)" " 
				     (bbdb-address-street3 addr)))
		(setq tonote (concat tonote "\n" (bbdb-address-zip-string addr) " "  (bbdb-address-city addr) ))
		))
	    (setq addrs (cdr addrs)))
	  )
	(cond (aka
	       (insert (format "%s: %s\n" "xmozillanickname"
			       (mapconcat (function identity) aka ", ")))
	       ))
	(let ((notes (bbdb-record-raw-notes record)))
	  (if (stringp notes)
	      (setq notes (list (cons 'notes notes))))
	  (while notes
	    (if (eq (car (car notes)) 'mail-alias)
		nil
	      (cond  ((eq (car (car notes)) 'creation-date)  (insert "createTimestamp:"))
		     ((eq (car (car notes)) 'timestamp)  (insert "modifyTimestamp:"))
		     ((eq (car (car notes)) 'notes)  (insert "description:"))
		((insert (format "%s:" (car (car notes)))))
		)
	      )
	    (if (eq (car (car notes)) 'notes)
		(progn
		  (setq tonote nil)
		  (insert (donote (concat tonote (cdr (car notes)))) "\n"))
	      (insert (cdr (car notes)) "\n")
	      )
	    (setq notes (cdr notes))
	    )
	      (if tonote (insert "description::" (donote tonote ) "\n"))
	  )
	)
      (setq records (cdr records))
      )
    )
  (show-buffer (get-lru-window) ldifbuffer )
)
(define-key bbdb-mode-map "L"      'bbdb2ldif)


;;;; From bbdb-snarf with bugfix:
(defun bbdb-merge-internally-ldif (old-record new-record)
  "Merge two records.  NEW-RECORDS wins over OLD in cases of ties."
  (if (and (null (bbdb-record-firstname new-record))
	   (bbdb-record-firstname old-record))
      (bbdb-record-set-firstname new-record (bbdb-record-firstname old-record)))
  (if (and (null (bbdb-record-lastname new-record))
	   (bbdb-record-lastname old-record))
      (bbdb-record-set-lastname new-record (bbdb-record-lastname old-record)))
  (if (and (null (bbdb-record-company new-record))
	   (bbdb-record-company old-record))
      (bbdb-record-set-company new-record (bbdb-record-company old-record)))
  ;; nets
  (let ((old-nets (bbdb-record-net old-record))
	(new-nets (bbdb-record-net new-record)))
    (while old-nets
      (if (not (member (car old-nets) new-nets))
	  (setq new-nets (append new-nets (list (car old-nets)))))
      (setq old-nets (cdr old-nets)))
    (bbdb-record-set-net new-record new-nets))
  ;; addrs
  (let ((old-addresses (bbdb-record-addresses old-record))
	(new-addresses (bbdb-record-addresses new-record)))
    (while old-addresses
      (if (not (member (car old-addresses) new-addresses))
	  (setq new-addresses (append new-addresses (list (car old-addresses)))))
      (setq old-addresses (cdr old-addresses)))
    (bbdb-record-set-addresses new-record new-addresses))
  ;; phones
  (let ((old-phones (bbdb-record-phones old-record))
	(new-phones (bbdb-record-phones new-record)))
    (while old-phones
      (if (not (member (car old-phones) new-phones))
	  (setq new-phones (append new-phones (list (car old-phones)))))
      (setq old-phones (cdr old-phones)))
    (bbdb-record-set-phones new-record new-phones))
  ;; notes
  (let ((old-notes (bbdb-record-raw-notes old-record))
	(new-notes (bbdb-record-raw-notes new-record)))
    (while old-notes
      (if (not (member (car old-notes) new-notes))
	  (setq new-notes (append new-notes (list (car old-notes)))))
      (setq old-notes (cdr old-notes)))
    (bbdb-record-set-raw-notes new-record new-notes))
  ;; return
  new-record)

;;;;======== end bbdb-ldif.el

--Multipart_Mon_Jul_13_14:11:23_1998-1
Content-Type: text/plain; charset=US-ASCII

   Niels Elgaard Larsen
   Department of Computer Science, University of Copenhagen, Denmark
   E-mail: elgaard@diku.dk <URL:http://www.diku.dk/users/elgaard/>

--Multipart_Mon_Jul_13_14:11:23_1998-1--
