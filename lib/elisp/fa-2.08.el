Article 1081 of gnu.emacs.sources:
x-gateway: relay6.UU.NET from garbage; Sun, 9 Jun 1996 02:38:23 EDT
From: kyle_jones@wonderworks.com
Date: Sun, 9 Jun 1996 02:38:08 -0400
Message-ID: <CAAathy03237.199606090638@crystal.WonderWorks.COM>
Newsgroups: gnu.emacs.sources
Subject: filladapt 2.08
Path: morgan.com!uunet!in2.uu.net!unreplyable!garbage
Lines: 789

The upgrade from 2.07 to 2.08 was mostly to fix a wee bit of
breakage introduced by the new fill code in Emacs 19.30 and
19.31.


#!/bin/sh
# shar:	Shell Archiver  (v1.22)
#
#	Run the following text with /bin/sh to create:
#	  filladapt.el
#
sed 's/^X//' << 'SHAR_EOF' > filladapt.el &&
X;;; Adaptive fill
X;;; Copyright (C) 1989, 1995, 1996 Kyle E. Jones
X;;;
X;;; This program is free software; you can redistribute it and/or modify
X;;; it under the terms of the GNU General Public License as published by
X;;; the Free Software Foundation; either version 2, or (at your option)
X;;; any later version.
X;;;
X;;; This program is distributed in the hope that it will be useful,
X;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
X;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X;;; GNU General Public License for more details.
X;;;
X;;; A copy of the GNU General Public License can be obtained from this
X;;; program's author (send electronic mail to kyle@uunet.uu.net) or from
X;;; the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
X;;; 02139, USA.
X;;;
X;;; Send bug reports to kyle@wonderworks.com
X
X;; LCD Archive Entry: 
X;; filladapt|Kyle Jones|kyle_jones@wonderworks.com| 
X;; Minor mode to adaptively set fill-prefix and overload filling functions|
X;; 10-June-1996|2.08|~/packages/filladapt.el| 
X
X;; These functions enhance the default behavior of Emacs' Auto Fill
X;; mode and the commands fill-paragraph, lisp-fill-paragraph and
X;; fill-region-as-paragraph.
X;;
X;; The chief improvement is that the beginning of a line to be
X;; filled is examined and, based on information gathered, an
X;; appropriate value for fill-prefix is constructed.  Also the
X;; boundaries of the current paragraph are located.  This occurs
X;; only if the fill prefix is not already non-nil.
X;;
X;; The net result of this is that blurbs of text that are offset
X;; from left margin by asterisks, dashes, and/or spaces, numbered
X;; examples, included text from USENET news articles, etc. are
X;; generally filled correctly with no fuss.
X;;
X;; Since this package replaces existing Emacs functions, it cannot
X;; be autoloaded.  Save this in a file named filladapt.el in a
X;; Lisp directory that Emacs knows about, byte-compile it and put
X;;    (require 'filladapt)
X;; in your .emacs file.
X;;
X;; Note that in this release Filladapt mode is a minor mode and it is
X;; _off_ by default.  If you want it to be on by default, use
X;;   (setq-default filladapt-mode t)
X;;
X;; M-x filladapt-mode toggles Filladapt mode on/off in the current
X;; buffer.
X;;
X;; Use
X;;     (add-hook 'text-mode-hook 'turn-on-filladapt-mode)
X;; to have Filladapt always enabled in Text mode.
X;;
X;; Use
X;;     (add-hook 'c-mode-hook 'turn-off-filladapt-mode)
X;; to have Filladapt always disabled in C mode.
X;;
X;; In many cases, you can extend Filladapt by adding appropriate
X;; entries to the following three `defvar's.  See `postscript-comment'
X;; or `texinfo-comment' as a sample of what needs to be done.
X;;
X;;     filladapt-token-table
X;;     filladapt-token-match-table
X;;     filladapt-token-conversion-table
X
X(provide 'filladapt)
X
X(defvar filladapt-version "2.08"
X  "Version string for filladapt.")
X
X(defvar filladapt-mode nil
X  "*Non-nil means that Filladapt minor mode is enabled.
XUse the filladapt-mode command to toggle the mode on/off.")
X(make-variable-buffer-local 'filladapt-mode)
X
X(defvar filladapt-mode-line-string " Filladapt"
X  "*String to display in the modeline when Filladapt mode is active.
XSet this to nil if you don't want a modeline indicator for Filladapt.")
X
X;; install on minor-mode-alist
X(or (assq 'filladapt-mode minor-mode-alist)
X    (setq minor-mode-alist (cons (list 'filladapt-mode
X				       'filladapt-mode-line-string)
X				 minor-mode-alist)))
X
X(defvar filladapt-token-table
X  '(
X    ;; Included text in news or mail replies
X    (">+" . citation->)
X    ;; Included text generated by SUPERCITE.  We can't hope to match all
X    ;; the possible variations, your mileage may vary.
X    ("[A-Za-z0-9][^'`\"< \t\n]*>[ \t]*" . supercite-citation)
X    ;; Lisp comments
X    (";+" . lisp-comment)
X    ;; UNIX shell comments
X    ("#+" . sh-comment)
X    ;; Postscript comments
X    ("%+" . postscript-comment)
X    ;; C++ comments
X    ("///*" . c++-comment)
X    ;; Texinfo comments
X    ("@c[ \t]" . texinfo-comment)
X    ("@comment[ \t]" . texinfo-comment)
X    ;; Bullet types.
X    ;;
X    ;; 1. xxxxx
X    ;;    xxxxx
X    ;;
X    ("[0-9]+\\.[ \t]" . bullet)
X    ;;
X    ;; 2.1.3  xxxxx xx x xx x
X    ;;        xxx
X    ;;
X    ("[0-9]+\\(\\.[0-9]+\\)+[ \t]" . bullet)
X    ;;
X    ;; a. xxxxxx xx
X    ;;    xxx xxx
X    ;;
X    ("[A-Za-z]\\.[ \t]" . bullet)
X    ;;
X    ;; 1) xxxx x xx x xx   or   (1) xx xx x x xx xx
X    ;;    xx xx xxxx                xxx xx x x xx x
X    ;;
X    ("(?[0-9]+)[ \t]" . bullet)
X    ;;
X    ;; a) xxxx x xx x xx   or   (a) xx xx x x xx xx
X    ;;    xx xx xxxx                xxx xx x x xx x
X    ;;
X    ("(?[A-Za-z])[ \t]" . bullet)
X    ;;
X    ;; 2a. xx x xxx x x xxx
X    ;;     xxx xx x xx x
X    ;;
X    ("[0-9]+[A-Za-z]\\.[ \t]" . bullet)
X    ;;
X    ;; 1a) xxxx x xx x xx   or   (1a) xx xx x x xx xx
X    ;;     xx xx xxxx                 xxx xx x x xx x
X    ;;
X    ("(?[0-9]+[A-Za-z])[ \t]" . bullet)
X    ;;
X    ;; -  xx xxx xxxx   or   *  xx xx x xxx xxx
X    ;;    xxx xx xx             x xxx x xx x x x
X    ;;
X    ("[-~*+]+[ \t]" . bullet)
X    ;;
X    ;; o  xx xxx xxxx xx x xx xxx x xxx xx x xxx
X    ;;    xxx xx xx 
X    ;;
X    ("o[ \t]" . bullet)
X    ;; don't touch
X    ("[ \t]+" . space)
X    ("$" . end-of-line)
X   )
X  "Table of tokens filladapt knows about.
XFormat is
X
X   ((REGEXP . SYM) ...)
X
Xfilladapt uses this table to build a tokenized representation of
Xthe beginning of the current line.  Each REGEXP is matched
Xagainst the beginning of the line until a match is found.
XMatching is done case-sensitively.  The corresponding SYM is
Xadded to the list, point is moved to (match-end 0) and the
Xprocess is repeated.  The process ends when there is no REGEXP in
Xthe table that matches what is at point.")
X
X(defvar filladapt-not-token-table
X  '(
X    "[Ee].g."
X    "[Ii].e."
X    ;; end-of-line isn't a token if whole line is empty
X    "^$"
X   )
X  "List of regexps that can never be a token.
XBefore trying the regular expressions in filladapt-token-table,
Xthe regexps in this list are tried.  If any regexp in this list
Xmatches what is at point then the token generator gives up and
Xdoesn't try any of the regexps in filladapt-token-table.
X
XRegexp matching is done case-sensitively.")
X
X(defvar filladapt-token-match-table
X  '(
X    (citation-> citation->)
X    (supercite-citation supercite-citation)
X    (lisp-comment lisp-comment)
X    (sh-comment sh-comment)
X    (postscript-comment postscript-comment)
X    (c++-comment c++-comment)
X    (texinfo-comment texinfo-comment)
X    (bullet)
X    (space bullet space)
X   )
X  "Table describing what tokens a certain token will match.
X
XTo decide whether a line belongs in the current paragraph,
Xfilladapt creates a token list for the fill prefix of both lines.
XTokens and the columns where tokens end are compared.  This table
Xspecifies what a certain token will match.
X
XTable format is
X
X   (SYM [SYM1 [SYM2 ...]])
X
XThe first symbol SYM is the token, subsequent symbols are the
Xtokens that SYM will match.")
X
X(defvar filladapt-token-match-many-table
X  '(
X    space
X   )
X  "List of tokens that can match multiple tokens.
XIf one of these tokens appears in a token list, it will eat all
Xmatching tokens in a token list being matched against it until it
Xencounters a token that doesn't match or a token that ends on
Xa greater column number.")
X
X(defvar filladapt-token-paragraph-start-table
X  '(
X    bullet
X   )
X  "List of tokens that indicate the start of a paragraph.
XIf parsing a line generates a token list containing one of
Xthese tokens, then the line is considered to be the start of a
Xparagraph.")
X
X(defvar filladapt-token-conversion-table
X  '(
X    (citation-> . exact)
X    (supercite-citation . exact)
X    (lisp-comment . exact)
X    (sh-comment . exact)
X    (postscript-comment . exact)
X    (c++-comment . exact)
X    (texinfo-comment . exact)
X    (bullet . spaces)
X    (space . exact)
X    (end-of-line . exact)
X   )
X  "Table that specifies how to convert a token into a fill prefix.
XTable format is
X
X   ((SYM . HOWTO) ...)
X
XSYM is the symbol naming the token to be converted.
XHOWTO specifies how to do the conversion.
X  `exact' means copy the token's string directly into the fill prefix.
X  `spaces' means convert all characters in the token string that are
X      not a TAB or a space into spaces and copy the resulting string into 
X      the fill prefix.")
X
X(defvar filladapt-function-table
X  (let ((assoc-list
X	 (list (cons 'fill-paragraph (symbol-function 'fill-paragraph))
X	       (cons 'fill-region-as-paragraph
X		     (symbol-function 'fill-region-as-paragraph))
X	       (cons 'do-auto-fill (symbol-function 'do-auto-fill)))))
X    ;; v18 Emacs doesn't have lisp-fill-paragraph
X    (if (fboundp 'lisp-fill-paragraph)
X	(nconc assoc-list
X	       (list (cons 'lisp-fill-paragraph
X			   (symbol-function 'lisp-fill-paragraph)))))
X    assoc-list )
X  "Table containing the old function definitions that filladapt usurps.")
X
X(defvar filladapt-fill-paragraph-post-hook nil
X  "Hooks run after filladapt runs fill-paragraph.")
X
X(defvar filladapt-inside-filladapt nil
X  "Non-nil if the filladapt version of a fill function executing.
XCurrently this is only checked by the filladapt version of
Xfill-region-as-paragraph to avoid this infinite recursion:
X
X  fill-region-as-paragraph -> fill-paragraph -> fill-region-as-paragraph ...")
X
X(defvar filladapt-debug nil
X  "Non-nil means filladapt debugging is enabled.
XUse the filladapt-debug command to turn on debugging.
X
XWith debugging enabled, filladapt will
X
X    a. display the proposed indentation with the tokens highlighted
X       using filladapt-debug-indentation-face-1 and
X       filladapt-debug-indentation-face-2.
X    b. display the current paragraph using the face specified by
X       filladapt-debug-paragraph-face.")
X
X(if filladapt-debug
X    (add-hook 'post-command-hook 'filladapt-display-debug-info-maybe))
X
X(defvar filladapt-debug-indentation-face-1 'highlight
X  "Face used to display the indentation when debugging is enabled.")
X
X(defvar filladapt-debug-indentation-face-2 'secondary-selection
X  "Another face used to display the indentation when debugging is enabled.")
X
X(defvar filladapt-debug-paragraph-face 'bold
X  "Face used to display the current paragraph when debugging is enabled.")
X
X(defvar filladapt-debug-indentation-extents nil)
X(make-variable-buffer-local 'filladapt-debug-indentation-extents)
X(defvar filladapt-debug-paragraph-extent nil)
X(make-variable-buffer-local 'filladapt-debug-paragraph-extent)
X
X;; kludge city, see references in code.
X(defvar filladapt-old-line-prefix)
X
X(defun do-auto-fill ()
X  (catch 'done
X    (if (and filladapt-mode (null fill-prefix))
X	(save-restriction
X	  (let ((paragraph-ignore-fill-prefix nil)
X		;; if the user wanted this stuff, they probably
X		;; wouldn't be using filladapt-mode.
X		(adaptive-fill-mode nil)
X		(adaptive-fill-regexp nil)
X		;; need this or Emacs 19 ignores fill-prefix when
X		;; inside a comment.
X		(comment-multi-line t)
X		(filladapt-inside-filladapt t)
X		fill-prefix retval)
X	    (if (filladapt-adapt nil nil)
X		(progn
X		  (setq retval (filladapt-funcall 'do-auto-fill))
X		  (throw 'done retval))))))
X    (filladapt-funcall 'do-auto-fill)))
X
X(defun filladapt-fill-paragraph (function arg)
X  (catch 'done
X    (if (and filladapt-mode (null fill-prefix))
X	(save-restriction
X	  (let ((paragraph-ignore-fill-prefix nil)
X		;; if the user wanted this stuff, they probably
X		;; wouldn't be using filladapt-mode.
X		(adaptive-fill-mode nil)
X		(adaptive-fill-regexp nil)
X		;; need this or Emacs 19 ignores fill-prefix when
X		;; inside a comment.
X		(comment-multi-line t)
X		fill-prefix retval)
X	    (if (filladapt-adapt t nil)
X		(progn
X		  (setq retval (filladapt-funcall function arg))
X		  (run-hooks 'filladapt-fill-paragraph-post-hook)
X		  (throw 'done retval))))))
X    ;; filladapt-adapt failed, so do fill-paragraph normally.
X    (filladapt-funcall function arg)))
X
X(defun fill-paragraph (arg)
X  (interactive "*P")
X  (let ((filladapt-inside-filladapt t))
X    (filladapt-fill-paragraph 'fill-paragraph arg)))
X
X(defun lisp-fill-paragraph (&optional arg)
X  (interactive "*P")
X  (let ((filladapt-inside-filladapt t))
X    (filladapt-fill-paragraph 'lisp-fill-paragraph arg)))
X
X(defun fill-region-as-paragraph (beg end &optional justify nosqueeze squeeze-after)
X  (interactive "*r\nP")
X  (if (and filladapt-mode (not filladapt-inside-filladapt))
X      (save-restriction
X	(narrow-to-region beg end)
X	(let ((filladapt-inside-filladapt t)
X	      line-start last-token)
X	  (goto-char beg)
X	  (end-of-line)
X	  (while (zerop (forward-line))
X	    (if (setq last-token
X		      (car (filladapt-tail (filladapt-parse-prefixes))))
X		(progn
X		  (setq line-start (point))
X		  (move-to-column (nth 1 last-token))
X		  (delete-region line-start (point))))
X	    ;; Dance...
X	    ;;
X	    ;; Do this instead of (delete-char -1) to keep
X	    ;; markers on the correct side of the whitespace.
X	    (goto-char (1- (point)))
X	    (insert " ")
X	    (delete-char 1)
X
X	    (end-of-line))
X	  (goto-char beg)
X	  (fill-paragraph justify))
X	;; In XEmacs 19.12 and Emacs 18.59 fill-region relies on
X	;; fill-region-as-paragraph to do this.  If we don't do
X	;; it, fill-region will spin in an endless loop.
X	(goto-char (point-max)))
X    (condition-case nil
X	;; five args for Emacs 19.31
X	(filladapt-funcall 'fill-region-as-paragraph beg end
X			   justify nosqueeze squeeze-after)
X      (wrong-number-of-arguments
X       (condition-case nil
X	   ;; four args for Emacs 19.29
X	   (filladapt-funcall 'fill-region-as-paragraph beg end
X			      justify nosqueeze)
X      ;; three args for the rest of the world.
X      (wrong-number-of-arguments
X	(filladapt-funcall 'fill-region-as-paragraph beg end justify)))))))
X
X(defvar zmacs-region-stays) ; for XEmacs
X
X(defun filladapt-mode (&optional arg)
X  "Toggle Filladapt minor mode.
XWith arg, turn Filladapt mode on iff arg is positive.  When
XFilladapt mode is enabled, auto-fill-mode and the fill-paragraph
Xcommand are both smarter about guessing a proper fill-prefix and
Xfinding paragraph boundaries when bulleted and indented lines and
Xparagraphs are used."
X  (interactive "P")
X  ;; don't deactivate the region.
X  (setq zmacs-region-stays t)
X  (setq filladapt-mode (or (and arg (> (prefix-numeric-value arg) 0))
X			   (and (null arg) (null filladapt-mode))))
X  (if (fboundp 'force-mode-line-update)
X      (force-mode-line-update)
X    (set-buffer-modified-p (buffer-modified-p))))
X
X(defun turn-on-filladapt-mode ()
X  "Unconditionally turn on Filladapt mode in the current buffer."
X  (filladapt-mode 1))
X
X(defun turn-off-filladapt-mode ()
X  "Unconditionally turn off Filladapt mode in the current buffer."
X  (filladapt-mode -1))
X
X(defun filladapt-funcall (function &rest args)
X  "Call the old definition of a function that filladapt has usurped."
X  (apply (cdr (assoc function filladapt-function-table)) args))
X
X(defun filladapt-paragraph-start (list)
X  "Returns non-nil if LIST contains a paragraph starting token.
XLIST should be a token list as returned by filladapt-parse-prefixes."
X  (catch 'done
X    (while list
X      (if (memq (car (car list)) filladapt-token-paragraph-start-table)
X	  (throw 'done t))
X      (setq list (cdr list)))))
X
X(defun filladapt-parse-prefixes ()
X  "Parse all the tokens after point and return a list of them.
XThe tokens regular expressions are specified in
Xfilladapt-token-table.  The list returned is of this form
X
X  ((SYM COL STRING) ...)
X
XSYM is a token symbol as found in filladapt-token-table.
XCOL is the column at which the token ended.
XSTRING is the token's text."
X  (save-excursion
X    (let ((token-list nil)
X	  (done nil)
X	  (old-point (point))
X	  (case-fold-search nil)
X	  token-table not-token-table)
X      (catch 'done
X	(while (not done)
X	  (setq not-token-table filladapt-not-token-table)
X	  (while not-token-table
X	    (if (looking-at (car not-token-table))
X		(throw 'done t))
X	    (setq not-token-table (cdr not-token-table)))
X	  (setq token-table filladapt-token-table
X		done t)
X	  (while token-table
X	    (if (null (looking-at (car (car token-table))))
X		(setq token-table (cdr token-table))
X	      (goto-char (match-end 0))
X	      (setq token-list (cons (list (cdr (car token-table))
X					   (current-column)
X					   (buffer-substring
X					    (match-beginning 0)
X					    (match-end 0)))
X				     token-list)
X		    token-table nil
X		    done (eq (point) old-point)
X		    old-point (point))))))
X      (nreverse token-list))))
X
X(defun filladapt-tokens-match-p (list1 list2)
X  "Compare two token lists and return non-nil if they match, nil otherwise.
XThe lists are walked through in lockstep, comparing tokens.
X
XWhen two tokens A and B are compared, they are considered to
Xmatch if
X
X    1. A appears in B's list of matching tokens or
X       B appears in A's list of matching tokens
Xand
X    2. A and B both end at the same column
X         or
X       A can match multiple tokens and ends at a column > than B
X         or
X       B can match multiple tokens and ends at a column > than A
X
XIn the case where the end columns differ the list pointer for the
Xtoken with the greater end column is not moved forward, which
Xallows its current token to be matched against the next token in
Xthe other list in the next iteration of the matching loop.
X
XAll tokens must be matched in order for the lists to be considered
Xmatching."
X  (let ((matched t)
X	(done nil))
X    (while (and (not done) list1 list2)
X      (let* ((token1 (car (car list1)))
X	     (token1-matches-many-p
X	         (memq token1 filladapt-token-match-many-table))
X	     (token1-matches (cdr (assq token1 filladapt-token-match-table)))
X	     (token1-endcol (nth 1 (car list1)))
X	     (token2 (car (car list2)))
X	     (token2-matches-many-p
X	         (memq token2 filladapt-token-match-many-table))
X	     (token2-matches (cdr (assq token2 filladapt-token-match-table)))
X	     (token2-endcol (nth 1 (car list2)))
X	     (tokens-match (or (memq token1 token2-matches)
X			       (memq token2 token1-matches))))
X	(cond ((not tokens-match)
X	       (setq matched nil
X		     done t))
X	      ((and token1-matches-many-p token2-matches-many-p)
X	       (cond ((= token1-endcol token2-endcol)
X		      (setq list1 (cdr list1)
X			    list2 (cdr list2)))
X		     ((< token1-endcol token2-endcol)
X		      (setq list1 (cdr list1)))
X		     (t
X		      (setq list2 (cdr list2)))))
X	      (token1-matches-many-p
X	       (cond ((= token1-endcol token2-endcol)
X		      (setq list1 (cdr list1)
X			    list2 (cdr list2)))
X		     ((< token1-endcol token2-endcol)
X		      (setq matched nil
X			    done t))
X		     (t
X		      (setq list2 (cdr list2)))))
X	      (token2-matches-many-p
X	       (cond ((= token1-endcol token2-endcol)
X		      (setq list1 (cdr list1)
X			    list2 (cdr list2)))
X		     ((< token2-endcol token1-endcol)
X		      (setq matched nil
X			    done t))
X		     (t
X		      (setq list1 (cdr list1)))))
X	      ((= token1-endcol token2-endcol)
X	       (setq list1 (cdr list1)
X		     list2 (cdr list2)))
X	      (t
X	       (setq matched nil
X		     done t)))))
X    (and matched (null list1) (null list2)) ))
X
X(defun filladapt-make-fill-prefix (list)
X  "Build a fill-prefix for a token LIST.
Xfilladapt-token-conversion-table specifies how this is done."
X  (let ((prefix-list nil)
X	(conversion-spec nil))
X    (while list
X      (setq conversion-spec (cdr (assq (car (car list))
X				       filladapt-token-conversion-table)))
X      (cond ((eq conversion-spec 'spaces)
X	     (setq prefix-list
X		   (cons
X		    (filladapt-convert-to-spaces (nth 2 (car list)))
X		    prefix-list)))
X	    ((eq conversion-spec 'exact)
X	     (setq prefix-list
X		   (cons
X		    (nth 2 (car list))
X		    prefix-list))))
X      (setq list (cdr list)))
X    (apply (function concat) (nreverse prefix-list)) ))
X
X(defun filladapt-convert-to-spaces (string)
X  "Return a copy of STRING, with all non-tabs and non-space changed to spaces."
X  (let ((i 0)
X	(space-list '(?\  ?\t))
X	(space ?\ )
X	(lim (length string)))
X    (setq string (copy-sequence string))
X    (while (< i lim)
X      (if (not (memq (aref string i) space-list))
X	  (aset string i space))
X      (setq i (1+ i)))
X    string ))
X
X(defun filladapt-adapt (paragraph debugging)
X  "Set fill-prefix based on the contents of the current line.
X
XIf the first arg PARAGRAPH is non-nil, also set a clipping region
Xaround the current paragraph.
X
XIf the second arg DEBUGGING is non-nil, don't do the kludge that's
Xnecessary to make certain paragraph fills work properly."
X  (save-excursion
X    (beginning-of-line)
X    (let ((token-list (filladapt-parse-prefixes))
X	  curr-list done)
X      (if (null token-list)
X	  nil
X	(setq fill-prefix (filladapt-make-fill-prefix token-list))
X	(if paragraph
X	    (let (beg end)
X	      (if (filladapt-paragraph-start token-list)
X		  (setq beg (point))
X		(save-excursion
X		  (setq done nil)
X		  (while (not done)
X		    (cond ((not (= 0 (forward-line -1)))
X			   (setq done t
X				 beg (point)))
X			  ((not (filladapt-tokens-match-p
X				 token-list
X				 (setq curr-list (filladapt-parse-prefixes))))
X			   (forward-line 1)
X			   (setq done t
X				 beg (point)))
X			  ((filladapt-paragraph-start curr-list)
X			   (setq done t
X				 beg (point)))))))
X	      (save-excursion
X		(setq done nil)
X		(while (not done)
X		  (cond ((not (= 0 (progn (end-of-line) (forward-line 1))))
X			 (setq done t
X			       end (point)))
X			((not (filladapt-tokens-match-p
X			       token-list
X			       (setq curr-list (filladapt-parse-prefixes))))
X			 (setq done t
X			       end (point)))
X			((filladapt-paragraph-start curr-list)
X			 (setq done t
X			       end (point))))))
X	      (narrow-to-region beg end)
X	      ;; Multiple spaces after the bullet at the start of
X	      ;; a hanging list paragraph get squashed by
X	      ;; fill-paragraph.  We kludge around this by
X	      ;; replacing the line prefix with the fill-prefix
X	      ;; used by the rest of the lines in the paragraph.
X	      ;; fill-paragraph will not alter the fill prefix so
X	      ;; we win.  The post hook restores the old line prefix
X	      ;; after fill-paragraph has been called.
X	      (if (and paragraph (not debugging))
X		  (let (col)
X		    (setq col (nth 1 (car (filladapt-tail token-list))))
X		    (goto-char (point-min))
X		    (move-to-column col)
X		    (setq filladapt-old-line-prefix
X			  (buffer-substring (point-min) (point)))
X		    (delete-region (point-min) (point))
X		    (insert fill-prefix)
X		    (add-hook 'filladapt-fill-paragraph-post-hook
X			      'filladapt-cleanup-kludge-at-point-min)))))
X	t ))))
X
X(defun filladapt-cleanup-kludge-at-point-min ()
X  "Cleanup the paragraph fill kludge.
XSee filladapt-adapt."
X  (save-excursion
X    (goto-char (point-min))
X    (insert filladapt-old-line-prefix)
X    (delete-char (length fill-prefix))
X    (remove-hook 'filladapt-fill-paragraph-post-hook
X		 'filladapt-cleanup-kludge-at-point-min)))
X
X(defun filladapt-tail (list)
X  "Returns the last cons in LIST."
X  (if (null list)
X      nil
X    (while (consp (cdr list))
X      (setq list (cdr list)))
X    list ))
X
X(defun filladapt-delete-extent (e)
X  (if (fboundp 'delete-extent)
X      (delete-extent e)
X    (delete-overlay e)))
X
X(defun filladapt-make-extent (beg end)
X  (if (fboundp 'make-extent)
X      (make-extent beg end)
X    (make-overlay beg end)))
X
X(defun filladapt-set-extent-endpoints (e beg end)
X  (if (fboundp 'set-extent-endpoints)
X      (set-extent-endpoints e beg end)
X    (move-overlay e beg end)))
X
X(defun filladapt-set-extent-property (e prop val)
X  (if (fboundp 'set-extent-property)
X      (set-extent-property e prop val)
X    (overlay-put e prop val)))
X
X(defun filladapt-debug ()
X  "Toggle filladapt debugging on/off in the current buffer."
X;;  (interactive)
X  (make-local-variable 'filladapt-debug)
X  (setq filladapt-debug (not filladapt-debug))
X  ;; make sure these faces exist at least
X  (make-face 'filladapt-debug-indentation-face-1)
X  (make-face 'filladapt-debug-indentation-face-2)
X  (make-face 'filladapt-debug-paragraph-face)
X  (if (null filladapt-debug)
X      (progn
X	(mapcar (function (lambda (e) (filladapt-set-extent-endpoints e 1 1)))
X		filladapt-debug-indentation-extents)
X	(if filladapt-debug-paragraph-extent
X	    (progn
X	      (filladapt-delete-extent filladapt-debug-paragraph-extent)
X	      (setq filladapt-debug-paragraph-extent nil)))))
X  (add-hook 'post-command-hook 'filladapt-display-debug-info-maybe))
X
X(defun filladapt-display-debug-info-maybe ()
X  (cond ((null filladapt-debug) nil)
X	(fill-prefix nil)
X	(t
X	 (if (null filladapt-debug-paragraph-extent)
X	     (let ((e (filladapt-make-extent 1 1)))
X	       (filladapt-set-extent-property e 'detachable nil)
X	       (filladapt-set-extent-property e 'evaporate nil)
X	       (filladapt-set-extent-property e 'face
X					      filladapt-debug-paragraph-face)
X	       (setq filladapt-debug-paragraph-extent e)))
X	 (save-excursion
X	   (save-restriction
X	     (let ((ei-list filladapt-debug-indentation-extents)
X		   (ep filladapt-debug-paragraph-extent)
X		   (face filladapt-debug-indentation-face-1)
X		   fill-prefix token-list)
X	       (if (null (filladapt-adapt t t))
X		   (progn
X		     (filladapt-set-extent-endpoints ep 1 1)
X		     (while ei-list
X		       (filladapt-set-extent-endpoints (car ei-list) 1 1)
X		       (setq ei-list (cdr ei-list))))
X		 (filladapt-set-extent-endpoints ep (point-min) (point-max))
X		 (beginning-of-line)
X		 (setq token-list (filladapt-parse-prefixes))
X		 (message "(%s)" (mapconcat (function
X					   (lambda (q) (symbol-name (car q))))
X					  token-list
X					  " "))
X		 (while token-list
X		   (if ei-list
X		       (setq e (car ei-list)
X			     ei-list (cdr ei-list))
X		     (setq e (filladapt-make-extent 1 1))
X		     (filladapt-set-extent-property e 'detachable nil)
X		     (filladapt-set-extent-property e 'evaporate nil)
X		     (setq filladapt-debug-indentation-extents
X			   (cons e filladapt-debug-indentation-extents)))
X		   (filladapt-set-extent-property e 'face face)
X		   (filladapt-set-extent-endpoints e (point)
X						   (progn
X						     (move-to-column
X						      (nth 1
X							   (car token-list)))
X						     (point)))
X		   (if (eq face filladapt-debug-indentation-face-1)
X		       (setq face filladapt-debug-indentation-face-2)
X		     (setq face filladapt-debug-indentation-face-1))
X		   (setq token-list (cdr token-list)))
X		 (while ei-list
X		   (filladapt-set-extent-endpoints (car ei-list) 1 1)
X		   (setq ei-list (cdr ei-list))))))))))
SHAR_EOF
chmod 0644 filladapt.el || echo "restore of filladapt.el fails"
exit 0


