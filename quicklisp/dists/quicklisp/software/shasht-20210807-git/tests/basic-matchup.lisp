(ql:quickload :cl-json)
(ql:quickload :jonathan)
(ql:quickload :json-streams)
(ql:quickload :jsown)
(ql:quickload :shasht)
(ql:quickload :st-json)
(ql:quickload :yason)

(defparameter control-chars
              `((,(code-char 0) "\"\\\u0000\"")
                (,(code-char 1) "\"\\\u0001\"")
                (,(code-char 2) "\"\\\u0002\"")
                (,(code-char 3) "\"\\\u0003\"")
                (,(code-char 4) "\"\\\u0004\"")
                (,(code-char 5) "\"\\\u0005\"")
                (,(code-char 6) "\"\\\u0006\"")
                (,(code-char 7) "\"\\\u0007\"")
                (#\Backspace "\"\\b\"" "\"\\\u0008\"")
                (#\Tab "\"\\t\"" "\"\\\u0009\"")
                (#\Newline "\"\\n\"" "\"\\\u000A\"")
                (,(code-char 11) "\"\\\u000B\"")
                (#\Page "\"\\f\"" "\"\\\u000C\"")
                (#\Return "\"\\r\"" "\"\\\u000D\"")
                (,(code-char 14) "\"\\\u000E\"")
                (,(code-char 15) "\"\\\u000F\"")
                (,(code-char 16) "\"\\\u0010\"")
                (,(code-char 17) "\"\\\u0011\"")
                (,(code-char 18) "\"\\\u0012\"")
                (,(code-char 19) "\"\\\u0013\"")
                (,(code-char 20) "\"\\\u0014\"")
                (,(code-char 21) "\"\\\u0015\"")
                (,(code-char 22) "\"\\\u0016\"")
                (,(code-char 23) "\"\\\u0017\"")
                (,(code-char 24) "\"\\\u0018\"")
                (,(code-char 25) "\"\\\u0019\"")
                (,(code-char 26) "\"\\\u001A\"")
                (,(code-char 27) "\"\\\u001B\"")
                (,(code-char 28) "\"\\\u001C\"")
                (,(code-char 29) "\"\\\u001D\"")
                (,(code-char 30) "\"\\\u001E\"")
                (,(code-char 31) "\"\\\u001F\"")
                (#\" "\"\\\"\"")
                (#\\ "\"\\\\\"")
                (,(code-char 127) "\"\\\u007F\"")))

(defun test-control-chars (name encode-json)
  (let ((yes (count-if (lambda (pair)
                         (handler-case
                             (member (apply encode-json (list (string (car pair)))) (cdr pair) :test #'equalp)
                           (serious-condition (condition)
                             (declare (ignore condition)))))
                       control-chars)))
    (format t "Test of ~A encoding~%  Correct: ~S~%  Incorrect: ~S~%~%" name yes (- (length control-chars) yes))))

(test-control-chars "cl-json" #'cl-json:encode-json-to-string)
(test-control-chars "jonathan" #'jojo:to-json)
(test-control-chars "json-streams" #'json-streams:json-stringify)
(test-control-chars "jsown" #'jsown:to-json)
(test-control-chars "shasht" #'shasht:to-json)
(test-control-chars "st-json" #'st-json:write-json-to-string)
(test-control-chars "yason" (lambda (s) (with-output-to-string (f) (yason:encode s f))))

(defparameter *results* nil)

(defun test-parse (name parse-json)
  (format t "Test of ~A parsing~%" name)
  (let ((s "{\"key1\":\"value\",\"key2\":1,\"key3\":[\"Hello\",1.2e-34]}")
;  (let ((s "{\"key1\":\"value\",\"key2\":1.1,\"key3\":[\"Hello\",1.2]}")
        (iter 1000000)
        (st (get-internal-run-time)))
    (time
      (dotimes (_ iter)
        (apply parse-json (list s))))
    (push (cons name (- (get-internal-run-time) st)) *results*)))

(test-parse "cl-json" #'cl-json:decode-json-from-string)
(test-parse "jonathan" (lambda (s) (jojo:parse s :as :alist)))
(test-parse "json-streams" #'json-streams:json-parse)
(test-parse "jsown" #'jsown:parse)
(test-parse "shasht" #'shasht:from-json)
(test-parse "st-json" #'st-json:read-json)
(test-parse "yason" #'yason:parse)

(format t "~S~%" (sort
  (let ((min-time (apply #'min (mapcar #'cdr *results*))))
    (mapcar (lambda (pair) (cons (car pair) (coerce (/ (cdr pair) min-time) 'double-float))) *results*))
 #'< :key #'cdr))


